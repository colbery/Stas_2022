<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>360</title>
    <link rel="shortcut icon" href="favicon.png" />
    <link
      href="https://fonts.googleapis.com/css?family=Anton"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat:400,700"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/shared.css" />
    <link rel="stylesheet" href="/css/main.css" />

       <script type="text/javascript">
      var gl;
      var shaderProgram;
      var uPMatrix;
      var vertexPositionBuffer;
      //var vertexColorBuffer;
      var indexBuffer;

      var fi;

      function MatrixMul(a, b) {
        //Mnożenie macierzy
        c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            c[i * 4 + j] = 0.0;
            for (let k = 0; k < 4; k++) {
              c[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
            }
          }
        }
        return c;
      }

      function octahedronMesh() {
        let vertexPosition = [
          //square mid
          0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,

          //square left up mf
          -2.598, 1.5, -1.732, 1, -2.098, 2.366, -2.098, 2.366, -1.732, 1,
          -1.232, 1.866,
          //square left down mf
          -2.598, -0.5, -1.732, 0, -2.098, -1.366, -2.098, -1.366, -1.732, 0,
          -1.232, -0.866,
          //square right up mf
          3.598, 1.5, 2.732, 1, 3.098, 2.366, 3.098, 2.366, 2.732, 1, 2.232,
          1.866,
          //square right down mf
          2.732, 0, 3.598, -0.5, 2.232, -0.866, 2.232, -0.866, 3.598, -0.5,
          3.098, -1.366,
          //square far left
          -3.464, 0, -3.464, 1, -4.464, 0, -4.464, 0, -4.464, 1, -3.464, 1,

          //hexagon1 right from square mid
          1, 0, 1, 1, 2.732, 0, 1, 1, 2.732, 1, 2.732, 0, 1, 1, 2.732, 1, 1.866,
          1.5, 1, 0, 2.732, 0, 1.866, -0.5,

          //hexagon2 far right from square mid
          2.732, 0, 2.732, 1, 4.464, 0, 2.732, 1, 4.464, 1, 4.464, 0, 2.732, 1,
          4.464, 1, 3.598, 1.5, 2.732, 0, 4.464, 0, 3.598, -0.5,

          //hexagon3 left from square mid
          -1.732, 0, -1.732, 1, 0, 0, -1.732, 1, 0, 1, 0, 0, -1.732, 1, 0, 1,
          -0.866, 1.5, -1.732, 0, 0, 0, -0.866, -0.5,

          //hexagon4 far left from square mid
          -1.732, 0, -1.732, 1, -3.464, 0, -3.464, 0, -3.464, 1, -1.732, 1,
          -1.732, 1, -2.598, 1.5, -3.464, 1, -1.732, 0, -2.598, 0.5, -3.464, 0,
          -1.732, 0, -3.464, 0, -2.598, -0.5,

          //hexagon5 top from square mid
          0, 1, 1, 1, 0, 2.732, 1, 2.732, 1, 1, 0, 2.732, 0, 1, 0, 2.732, -0.5,
          1.866, 1, 1, 1, 2.732, 1.5, 1.866,

          //hexagon6 far top from square mid
          0, 2.732, 1, 2.732, 0, 4.464, 0, 4.464, 1, 4.464, 1, 2.732, 0, 2.732,
          0, 4.464, -0.5, 3.598, 1, 2.732, 1, 4.464, 1.5, 3.598,

          //hexagon7 low from square mid
          0, 0, 1, 0, 0, -1.732, 1, 0, 0, -1.732, 1, -1.732, 0, 0, 0, -1.732,
          -0.5, -0.866, 1, 0, 1, -1.732, 1.5, -0.866,

          //hexagon8 far low from square mid
          0, -1.732, 1, -1.732, 0, -3.464, 1, -1.732, 0, -3.464, 1, -3.464, 0,
          -1.732, 0, -3.464, -0.5, -2.598, 1, -1.732, 1, -3.464, 1.5, -2.598,
        ];
        return vertexPosition;
      }

      function createDodecahedron() {
        const t = (1 + Math.sqrt(5)) / 2;
        const d = t - 1;

        console.log(`a = ${2 * d}`);

        let vertexPosition = [
          1,
          1,
          1,
          t,
          0,
          d,
          t,
          0,
          -d, //*/

          1,
          1,
          1,
          t,
          0,
          -d,
          1,
          1,
          -1, //*/

          1,
          1,
          1,
          1,
          1,
          -1,
          d,
          t,
          0, //*/

          t,
          0,
          -d,
          1,
          -1,
          -1,
          0,
          -d,
          -t, //*/

          t,
          0,
          -d,
          0,
          -d,
          -t,
          0,
          d,
          -t, //*/

          t,
          0,
          -d,
          0,
          d,
          -t,
          1,
          1,
          -1, //*/

          0,
          -d,
          -t,
          -1,
          -1,
          -1,
          -t,
          0,
          -d, //*/

          0,
          -d,
          -t,
          -t,
          0,
          -d,
          -1,
          1,
          -1, //*/

          0,
          -d,
          -t,
          -1,
          1,
          -1,
          0,
          d,
          -t, //*/

          -t,
          0,
          d,
          -1,
          -1,
          1,
          0,
          -d,
          t, //*/

          -t,
          0,
          d,
          0,
          -d,
          t,
          0,
          d,
          t, //*/

          -t,
          0,
          d,
          0,
          d,
          t,
          -1,
          1,
          1, //*/

          0,
          d,
          t,
          0,
          -d,
          t,
          1,
          -1,
          1, //*/

          0,
          d,
          t,
          1,
          -1,
          1,
          t,
          0,
          d, //*/

          0,
          d,
          t,
          t,
          0,
          d,
          1,
          1,
          1, //*/

          t,
          0,
          d,
          1,
          -1,
          1,
          d,
          -t,
          0, //*/

          t,
          0,
          d,
          d,
          -t,
          0,
          1,
          -1,
          -1, //*/

          t,
          0,
          d,
          1,
          -1,
          -1,
          t,
          0,
          -d, //*/

          1,
          1,
          -1,
          0,
          d,
          -t,
          -1,
          1,
          -1, //*/
          //*
          //_________________________________________________________
          //wierzcholki ze zla interpolacją na teksture

          // -1,  1,  1,
          // 0,  d,  t,
          // 1,  1,  1,//*/

          // -1,  1,  1,
          //   1,  1,  1,
          //   d,  t,  0,//*/

          // -1,  1,  1,
          //   d,  t,  0,
          // -d,  t,  0,//*/

          //  -1, -1, -1,
          //  -d, -t,  0,
          //  -1, -1,  1,//*/

          //  -1, -1, -1,
          //  -1, -1,  1,
          //  -t,  0,  d,//*/

          //  -1, -1, -1,
          //  -t,  0,  d,
          //  -t,  0, -d,//*/

          //  -1,  1, -1,
          //  -t,  0, -d,
          //  -t,  0,  d,//*/

          //  -1,  1, -1,
          //  -t,  0,  d,
          //  -1,  1,  1,//*/

          //  -1,  1, -1,
          //  -1,  1,  1,
          //  -d,  t,  0,//*/

          //   1, -1, -1,
          //   d, -t,  0,
          //  -d, -t,  0,//*/

          //   1, -1, -1,
          //  -d, -t,  0,
          //  -1, -1, -1,//*/

          //   1, -1, -1,
          //  -1, -1, -1,
          //   0, -d, -t,//*/

          //            -1, -1, -1,
          //            -d, -t,  0,
          //            -1, -1,  1,//*/

          //            -1, -1, -1,
          //            -1, -1,  1,
          //            -t,  0,  d,//*/

          //            -1, -1, -1,
          //            -t,  0,  d,
          //            -t,  0, -d,//*/

          //            -1,  1, -1,
          //            -t,  0, -d,
          //            -t,  0,  d,//*/

          //            -1,  1, -1,
          //            -t,  0,  d,
          //            -1,  1,  1,//*/

          //            -1,  1, -1,
          //            -1,  1,  1,
          //            -d,  t,  0,//*/

          //                       -1,  1,  1,
          //             d,  t,  0,
          //           -d,  t,  0,//*/

          //             1,  1, -1,
          //            -1,  1, -1,
          //            -d,  t,  0,//*/

          //             1,  1, -1,
          //            -d,  t,  0,
          //             d,  t,  0,//*/

          //            -1, -1,  1,
          //            -d, -t,  0,
          //             d, -t,  0,//*/
          //  //*
          //            -1, -1,  1,
          //   	        d, -t,  0,
          //             1, -1,  1,//*/
          //   //*
          //            -1, -1,  1,
          //             1, -1,  1,
          //             0, -d,  t//*/

          //_________________________________________________________

          //poprawione wierzcholki
          -d,
          -t,
          -0.000001,
          -t,
          0,
          -0.000001,
          -t,
          0,
          -d, //*/

          -d,
          -t,
          0,
          -t,
          0,
          d,
          -t,
          0,
          0, //*/

          -d,
          -t,
          -0.000001,
          -t,
          0,
          -d, //*/
          -1,
          -1,
          -1,

          -d,
          -t,
          0,
          -1,
          -1,
          1,
          -t,
          0,
          d,

          //___________________________________________
          -d,
          t,
          -0.000001,
          -t,
          0,
          -d,
          -t,
          0,
          -0.00001, //*/

          -d,
          t,
          0,
          -t,
          0,
          0,
          -t,
          0,
          d, //*/

          -d,
          t,
          0,
          -t,
          0,
          d,
          -1,
          1,
          1, //*/

          -d,
          t,
          -0.0000001,
          -1,
          1,
          -1,
          -t,
          0,
          -d, //*/

          //___________________________________________

          0,
          -d,
          -t,
          -1,
          -1,
          -1,
          1,
          -1,
          -1, //*/

          1,
          -1,
          -1,
          -1,
          -1,
          -1,
          0,
          -t + 0.00001,
          -0.00001,

          -1,
          -1,
          -1,
          0,
          -t + 0.00001,
          -0.00001,
          -d,
          -t + 0.00001,
          -0.00001,

          1,
          -1,
          -1,
          0,
          -t + 0.00001,
          -0.00001,
          d,
          -t + 0.00001,
          -0.00001,

          //___________________________________________
          0,
          -d,
          t,
          -1,
          -1,
          1,
          1,
          -1,
          1, //*/

          1,
          -1,
          1,
          -1,
          -1,
          1,
          0,
          -t + 0.00001,
          0.00001,

          -1,
          -1,
          1,
          0,
          -t + 0.00001,
          0.00001,
          -d,
          -t + 0.00001,
          0.00001,

          1,
          -1,
          1,
          0,
          -t + 0.00001,
          0.00001,
          d,
          -t + 0.00001,
          0.00001,

          //___________________________________________
          0,
          d,
          t,
          -1,
          1,
          1,
          1,
          1,
          1, //*/

          1,
          1,
          1,
          -1,
          1,
          1,
          0,
          t + 0.00001,
          0.00001,

          -1,
          1,
          1,
          0,
          t + 0.00001,
          0.00001,
          -d,
          t + 0.00001,
          0.00001,

          1,
          1,
          1,
          0,
          t + 0.00001,
          0.00001,
          d,
          t + 0.00001,
          0.00001,

          //___________________________________________
          1,
          1,
          -1,
          -1,
          1,
          -1,
          0,
          t + 0.00001,
          -0.00001,

          -1,
          1,
          -1,
          0,
          t + 0.00001,
          -0.00001,
          -d,
          t + 0.00001,
          -0.00001,

          1,
          1,
          -1,
          0,
          t + 0.00001,
          -0.00001,
          d,
          t + 0.00001,
          -0.00001,
        ];

        return vertexPosition;
      }
      var t = (1 + Math.sqrt(5)) / 2;
      const d = t - 1;

      function face(x = 0, y = 0) {
        const c1 = Math.cos((2 * Math.PI) / 5);
        const c2 = Math.cos(Math.PI / 5);
        const s1 = Math.sin((2 * Math.PI) / 5);
        const s2 = Math.sin((4 * Math.PI) / 5);

        array = [
          x,
          y + 1,
          0,
          x + s2,
          y - c2,
          0,
          x - s2,
          y - c2,
          0,
          x,
          y + 1,
          0,
          x + s2,
          y - c2,
          0,
          x + s1,
          y + c1,
          0,
          x,
          y + 1,
          0,
          x - s2,
          y - c2,
          0,
          x - s1,
          y + c1,
          0,
        ];

        return array;
      }

      function reverseFace(x = 0, y = 0) {
        let pentagon = face(x, y);
        let result = [];

        for (let i = 0; i < 27; i += 3) {
          result.push(-pentagon[i]);
          result.push(-pentagon[i + 1]);
          result.push(0);
        }
        return result;
      }

      function reversePentaflake(x, y) {
        let pentaflake = createPentaflake(x, y);
        let result = [];

        for (let i = 0; i < 6 * 27; i += 3) {
          result.push(-pentaflake[i]);
          result.push(-pentaflake[i + 1]);
          result.push(0);
        }
        return result;
      }

      function createPentaflake(x = 0, y = 0) {
        const a = Math.sin((4 * Math.PI) / 5) * 2;

        const fi = (1 + Math.sqrt(5)) / 2;
        const h = (Math.sqrt(5 + 2 * Math.sqrt(5)) / 2) * a;
        const R = (Math.sqrt(50 + 10 * Math.sqrt(5)) / 10) * a;
        const r = (Math.sqrt(25 + 10 * Math.sqrt(5)) / 10) * a;
        const e = (Math.sqrt(25 - 10 * Math.sqrt(5)) / 10) * a;

        const temp = (2 * r) / Math.sqrt(2);

        const face1 = face(-x, -y);
        const face2 = reverseFace(x + 0, y + 2 * r);
        const face3 = reverseFace(x - temp + e, y - temp - e);
        const face4 = reverseFace(x + temp - e, y - temp - e);
        const face5 = reverseFace(x + 2 * r - 0.07, y + temp - r + e - 0.03);
        const face6 = reverseFace(x - 2 * r + 0.07, y + temp - r + e - 0.03);

        const pentaflake1 = face1.concat(face2, face3, face4, face5, face6);

        return pentaflake1;
      }

      //console.log(vertexPosition);

      function createMesh(x1, y1) {
        const fi = (1 + Math.sqrt(5)) / 2;

        const pentaflake1 = createPentaflake(x1, y1);
        const pentaflake2 = reversePentaflake(x1 + 2.2 * fi, y1 + 2.2 * fi);

        const mesh = pentaflake1.concat(pentaflake2);

        return mesh;
      }

      function createCoordsDode() {
        let position = createDodecahedron();

        let vertexCoords = [];

        for (let i = 0; i < position.length; i += 3) {
          const X = position[i + 0];
          const Y = position[i + 1];
          const Z = position[i + 2];
          const fi = Math.atan2(-Z, X); //atan(-Z/X)
          const phi = Math.asin(Y / Math.sqrt(X * X + Y * Y + Z * Z)); //asin(Y/|R|)
          const u = fi / (2 * Math.PI) + 0.5;
          const v = phi / Math.PI + 0.5;

          vertexCoords.push(...[u, v]);
        }

        console.log(position.length);
        return vertexCoords;
      }

      function startGL() {
        f.onchange = upload;
var img = null;
var keys = [];
var bytes = 0;
var numFiles = 0;

function getKeys() {
  log.textContent = "Getting keys...";
  localforage.keys().then(function (keys) {
    this.keys = [];
    var f = document.getElementById("f");
    var ul = document.getElementById("list");
    if (keys.length === 1) {
      f.setAttribute("disabled", "disabled");
    }
    if (keys.length > 0) {
      clear_btn.disabled = false;
    }

    for (let i = 0; i < keys.length; i++) {
      var li = document.createElement("li");
      li.appendChild(document.createTextNode(keys[i]));
      ul.appendChild(li);
      ul.onclick = (e) => play(e.target.innerHTML);
      this.keys.push(keys[i]);
    }

    log.textContent = "Done";
  });
}
getKeys();
//getFile();

function stopAll() {
  console.log("stop all");
  if (this.img) {
    clearImage();
  }
}

function play(filename) {
  stopAll();

  const ext = filename.split(".").pop().toLowerCase();
  console.log(ext);
  switch (ext) {
    case "jpg":
    case "jpeg":
    case "png":
      showImage(filename);
      break;
    default:
      console.error("not a valid type");
      break;
  }
  window.scrollTo(1, 0);
}

function showImage(filename) {
  log.textContent = "loading: " + filename + "...";
  localforage.getItem(filename).then((blob) => {
   
    textureImg.src  = URL.createObjectURL(blob);

  });
}

function clearImage() {
  textureImg.src = "";
  this.img.style.display = "none";
}

function upload() {
  const promises = [];
  log.textContent = "Adding to localstorage...";

  for (let i = 0; i < this.files.length; i++) {
    addBytes(this.files[0].size);
    const promise = localforage.setItem(this.files[i].name, f.files[i]);
    promises.push(promise);
  }

  Promise.all(promises).then(() => {
    log.textContent = "Added Successfully.";
    getKeys();
  });
}

function addBytes(bytes) {
  console.log("param bytes: " + bytes);
  console.log("numFiles bytes: " + this.numFiles);
  this.bytes += bytes;
  this.numFiles += 1;
  console.log("numFiles: " + this.numFiles);
  console.log("total bytes: " + this.bytes);
  stats.textContent =
    this.numFiles + " items and " + this.bytes + " total bytes";
}


       
        let canvas = document.getElementById("canvas3D"); //wyszukanie obiektu w strukturze strony
        gl = canvas.getContext("experimental-webgl"); //pobranie kontekstu OpenGL'u z obiektu canvas
        gl.viewportWidth = canvas.width; //przypisanie wybranej przez nas rozdzielczości do systemu OpenGL
        gl.viewportHeight = canvas.height;

        //Kod shaderów
        const vertextShaderSource = ` //Znak akcentu z przycisku tyldy - na lewo od przycisku 1 na klawiaturze
    precision highp float;
    attribute vec3 aVertexPosition; 
    //attribute vec3 aVertexColor;
    attribute vec2 aVertexCoords;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    varying vec3 vColor;
    varying vec2 vTexUV;


    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); //Dokonanie transformacji położenia punktów z przestrzeni 3D do przestrzeni obrazu (2D)
      //vColor = aVertexColor;
      vTexUV = aVertexCoords;
    }
  `;
        const fragmentShaderSource = `
    precision highp float;
    //varying vec3 vColor;
    varying vec2 vTexUV;
    
    uniform sampler2D uSampler;
    void main(void) {
      //gl_FragColor = vec4(vColor,1.0); //Ustalenie stałego koloru wszystkich punktów sceny
      gl_FragColor = texture2D(uSampler,vTexUV); //Odczytanie punktu tekstury i przypisanie go jako koloru danego punktu renderowaniej figury
    }
  `;
        let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //Stworzenie obiektu shadera
        let vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource); //Podpięcie źródła kodu shader
        gl.shaderSource(vertexShader, vertextShaderSource);
        gl.compileShader(fragmentShader); //Kompilacja kodu shader
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          //Sprawdzenie ewentualnych błedów kompilacji
          alert(gl.getShaderInfoLog(fragmentShader));
          return null;
        }
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(vertexShader));
          return null;
        }

        shaderProgram = gl.createProgram(); //Stworzenie obiektu programu
        gl.attachShader(shaderProgram, vertexShader); //Podpięcie obu shaderów do naszego programu wykonywanego na karcie graficznej
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
          alert("Could not initialise shaders"); //Sprawdzenie ewentualnych błedów

        //let vertexPosition = createDodecahedron();
        let vertexPosition = createMesh(0, 0);
        //let vertexPosition = octahedronMesh();

        vertexPositionBuffer = gl.createBuffer(); //Stworzenie tablicy w pamieci karty graficznej
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertexPosition),
          gl.STATIC_DRAW
        );
        vertexPositionBuffer.itemSize = 3; //zdefiniowanie liczby współrzednych per wierzchołek
        //vertexPositionBuffer.numItems = vertexPosition.length/(3*3) //Zdefinoiowanie liczby punktów w naszym buforze
        vertexPositionBuffer.numItems = vertexPosition.length;

        let vertexCoords = createCoordsDode();
        console.log(vertexCoords.length);

        vertexCoordsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertexCoords),
          gl.STATIC_DRAW
        );
        vertexCoordsBuffer.itemSize = 2;
        vertexCoordsBuffer.numItems = 12;

        textureBuffer = gl.createTexture();
        var textureImg = new Image();

        textureImg.onload = function () {
          //Wykonanie kodu automatycznie po załadowaniu obrazka
          gl.bindTexture(gl.TEXTURE_2D, textureBuffer);
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            textureImg
          ); //Faktyczne załadowanie danych obrazu do pamieci karty graficznej
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Ustawienie parametrów próbkowania tekstury
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        };

        textureImg.src = ""; //Nazwa obrazka

        //Macierze opisujące położenie wirtualnej kamery w przestrzenie 3D
        let aspect = gl.viewportWidth / gl.viewportHeight;
        let fov = (45.0 * Math.PI) / 180.0; //Określenie pola widzenia kamery
        let zFar = 100.0; //Ustalenie zakresów renderowania sceny 3D (od obiektu najbliższego zNear do najdalszego zFar)
        let zNear = 0.1;
        uPMatrix = [
          1.0 / (aspect * Math.tan(fov / 2)),
          0,
          0,
          0,
          0,
          1.0 / Math.tan(fov / 2),
          0,
          0,
          0,
          0,
          -(zFar + zNear) / (zFar - zNear),
          -1,
          0,
          0,
          -(2 * zFar * zNear) / (zFar - zNear),
          0.0,
        ];

        Tick();
      }

      //let angle = 45.0; //Macierz transformacji świata - określenie położenia kamery
      var angleZ = 180.0;
      var angleY = 0.0;
      var angleX = 0.0;
      var tz = -12.0;

      function Tick() {
        let uMVMatrix = [
          1,
          0,
          0,
          0, //Macierz jednostkowa
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
        ];

        let uMVRotZ = [
          +Math.cos((angleZ * Math.PI) / 180.0),
          +Math.sin((angleZ * Math.PI) / 180.0),
          0,
          0,
          -Math.sin((angleZ * Math.PI) / 180.0),
          +Math.cos((angleZ * Math.PI) / 180.0),
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
        ];

        let uMVRotY = [
          +Math.cos((angleY * Math.PI) / 180.0),
          0,
          -Math.sin((angleY * Math.PI) / 180.0),
          0,
          0,
          1,
          0,
          0,
          +Math.sin((angleY * Math.PI) / 180.0),
          0,
          +Math.cos((angleY * Math.PI) / 180.0),
          0,
          0,
          0,
          0,
          1,
        ];

        let uMVRotX = [
          1,
          0,
          0,
          0,
          0,
          +Math.cos((angleX * Math.PI) / 180.0),
          +Math.sin((angleX * Math.PI) / 180.0),
          0,
          0,
          -Math.sin((angleX * Math.PI) / 180.0),
          +Math.cos((angleX * Math.PI) / 180.0),
          0,
          0,
          0,
          0,
          1,
        ];

        let uMVTranslateZ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, tz, 1];

        uMVMatrix = MatrixMul(uMVMatrix, uMVRotX);
        uMVMatrix = MatrixMul(uMVMatrix, uMVRotY);
        uMVMatrix = MatrixMul(uMVMatrix, uMVRotZ);

        uMVMatrix = MatrixMul(uMVMatrix, uMVTranslateZ);
        //alert(uPMatrix);

        //Render Scene
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clearColor(0.0, 0.0, 0.0, 0.1); //Wyczyszczenie obrazu kolorem czerwonym
        gl.clearDepth(1.0); //Wyczyścienie bufora głebi najdalszym planem
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(shaderProgram); //Użycie przygotowanego programu shaderowego

        gl.enable(gl.DEPTH_TEST); // Włączenie testu głębi - obiekty bliższe mają przykrywać obiekty dalsze
        gl.depthFunc(gl.LEQUAL); //

        gl.uniformMatrix4fv(
          gl.getUniformLocation(shaderProgram, "uPMatrix"),
          false,
          new Float32Array(uPMatrix)
        ); //Wgranie macierzy kamery do pamięci karty graficznej
        gl.uniformMatrix4fv(
          gl.getUniformLocation(shaderProgram, "uMVMatrix"),
          false,
          new Float32Array(uMVMatrix)
        );

        gl.enableVertexAttribArray(
          gl.getAttribLocation(shaderProgram, "aVertexPosition")
        ); //Przekazanie położenia
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
        gl.vertexAttribPointer(
          gl.getAttribLocation(shaderProgram, "aVertexPosition"),
          vertexPositionBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        gl.enableVertexAttribArray(
          gl.getAttribLocation(shaderProgram, "aVertexCoords")
        ); //Pass the geometry
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer);
        gl.vertexAttribPointer(
          gl.getAttribLocation(shaderProgram, "aVertexCoords"),
          vertexCoordsBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textureBuffer);
        gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);

        gl.drawArrays(
          gl.TRIANGLES,
          0,
          vertexPositionBuffer.numItems * vertexPositionBuffer.itemSize
        ); //Faktyczne wywołanie rendrowania

        //setTimeout(Tick,100);
        requestAnimationFrame(Tick);
      }
  
      function handlekeydown(e) {
        if (e.keyCode == 87) angleX = angleX + 5.0; //W
        if(event.keyCode==83) {
      var img = createImageFromTexture(gl, textureBuffer, canvas.width, canvas.height); 
      document.body.appendChild(img);
    }
        if (e.keyCode == 68) angleY = angleY + 5.0;
        if (e.keyCode == 65) angleY = angleY - 5.0;
        if (e.keyCode == 81) angleZ = angleZ + 5.0;
        if (e.keyCode == 69) angleZ = angleZ - 5.0;
        //alert(e.keyCode);
      }
    </script>
  </head>
  <body onload="startGL()" onkeydown="handlekeydown(event)">
    <canvas
      id="canvas3D"
      width="1920"
      height="1080"
      style="border: solid black 1px"
    ></canvas>
    <script src="https://cdn.rawgit.com/localForage/localForage/4ce19202/dist/localforage.min.js"></script>
<pre id="log" style="visibility: hidden;"></pre> </br>
<pre id="stats" style="visibility: hidden;"></pre>
    <header class="main-header">
      <div>
        <a href="/" class="main-header__brand"> 360 </a>
      </div>
      <nav class="main-nav">
        <ul class="main-nav__items">
          <li class="main-nav__item">
            <a href="/">Strona Główna</a>
          </li>

          <li class="main-nav__item main-nav__item--cta">
            <a href="/sfera">Zrób to !</a>
          </li>
        </ul>
      </nav>
    </header>
    <main>
      <section id="plans">
        <h1 class="section-title">Wprowadź zdjecię do wydruku</h1>

        
        <div class="text-1_noborder">
          <input type="file" id="f" accept="image/*"/>
        
            
          <button id="clear_btn" onclick="clearData()" disabled='true'>Wyczyść</button>
<button id="stop_btn" onclick="stopAll()">Przestań</button>


<br><br>
<div style="float: left;">  
  <ul id="list"></ul>
</div>
<div style="height: 338px; width: 600px; right: 10px;
  ">
  <video id="vid" style="width: 100%; 
    height: 100%;
                         display: none;
    object-fit: cover;"></video>
  <img id="img" style="width: 100%; 
    height: 100%;
                       display: none;
    object-fit: cover;"></img>

   
</div>
        </div>
      </section>
    </main>


    <script type="text/javascript">
      function clearData() {
  console.log("clear");
  log.textContent = "Clearing data...";
  for (let i = 0; i < this.keys.length; i++) {
    localforage.removeItem(this.keys[i]).then(() => {
      log.textContent = "Done";
      clear_btn.disabled = true;
      f.removeAttribute("disabled");
      var ul = document.getElementById("list");
      while (ul.firstChild) {
        ul.removeChild(ul.firstChild);
      }
      this.bytes = 0;
      document.getElementById("stats").textContent = "";
    });
  }
}

    </script>

  </body>
</html>
